
import asyncio
import json
import sqlite3
import time
from typing import Any, Dict, List, Optional, Set

import structlog

from src.logging_setup import setup_logging
from src.agents.architect_agent import ArchitectAgent
from src.agents.code_generator import CodeGenAgent
from src.agents.tester import TesterAgent
from src.agents.security_agent import SecurityAgent
from src.agents.deployment_agent import DeploymentAgent
from src.agents.fixer_agent import FixerAgent
from src.agents.base_agent import BaseAgent
from src.rag.retriever import Retriever
from src.repo_manager.repo_manager import RepoManager
from src.sandbox.sandbox_runner import SandboxRunner
from src.review_api import add_review, get_review_status
from src.metrics import TASK_COUNTER, TASK_DURATION


class Orchestrator:
    def __init__(self, db_path="orchestrator_state.db", retriever: Optional[Retriever] = None, repo_manager: Optional[RepoManager] = None, sandbox_runner: Optional[SandboxRunner] = None):
        self.db_path = db_path
        self.conn = sqlite3.connect(self.db_path)
        self._create_tables()
        self.logger = structlog.get_logger(__name__)
        self.retriever = retriever
        self.repo_manager = repo_manager
        self.sandbox_runner = sandbox_runner
        self.agents: Dict[str, BaseAgent] = {
            "ArchitectAgent": ArchitectAgent(retriever=self.retriever),
            "CodeGenAgent": CodeGenAgent(retriever=self.retriever),
            "TesterAgent": TesterAgent(sandbox_runner=self.sandbox_runner),
            "SecurityAgent": SecurityAgent(),
            "DeploymentAgent": DeploymentAgent(),
            "FixerAgent": FixerAgent(),
        }

    def _create_tables(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS task_runs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_name TEXT NOT NULL,
                status TEXT NOT NULL,
                result TEXT,
                started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                finished_at TIMESTAMP
            )
        ''')
        self.conn.commit()

    async def execute_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        task_name = task["name"]
        agent_name = task["agent"]
        retries = task.get("retries", 3)
        
        if agent_name not in self.agents:
            self.logger.error("Agent not found", agent_name=agent_name)
            return {"status": "failed", "error": f"Agent {agent_name} not found"}

        agent = self.agents[agent_name]
        start_time = time.time()

        for attempt in range(retries):
            try:
                self.logger.info("Executing task", task_name=task_name, attempt=attempt + 1)
                cursor = self.conn.cursor()
                cursor.execute("INSERT INTO task_runs (task_name, status) VALUES (?, ?)", (task_name, "running"))
                self.conn.commit()
                run_id = cursor.lastrowid

                # The prompt for the agent is the task description
                result = agent.run(task["description"], context_query=task.get("context_query"))

                if agent_name in ["CodeGenAgent", "DeploymentAgent"] and self.repo_manager and result["status"] == "completed":
                    files_to_commit = result.get("files", [])
                    if files_to_commit:
                        commit_message = f"feat: Generate files for {task_name}\n\nGenerated by {agent_name}."
                        self.repo_manager.commit_files(files_to_commit, commit_message)

                finished_at = time.time()
                duration = finished_at - start_time
                TASK_DURATION.labels(agent_name=agent_name).observe(duration)
                TASK_COUNTER.labels(agent_name=agent_name, status=result["status"]).inc()

                cursor.execute(
                    "UPDATE task_runs SET status = ?, result = ?, finished_at = ? WHERE id = ?",
                    (result["status"], json.dumps(result), finished_at, run_id),
                )
                self.conn.commit()
                self.logger.info("Task completed", task_name=task_name, result=result)
                return result
            except Exception as e:
                self.logger.error("Task failed", task_name=task_name, error=str(e))
                if attempt + 1 == retries:
                    finished_at = time.time()
                    duration = finished_at - start_time
                    TASK_DURATION.labels(agent_name=agent_name).observe(duration)
                    TASK_COUNTER.labels(agent_name=agent_name, status="failed").inc()
                    cursor.execute(
                        "UPDATE task_runs SET status = ?, result = ?, finished_at = ? WHERE id = ?",
                        ("failed", json.dumps({"error": str(e)}), finished_at, run_id),
                    )
                    self.conn.commit()
                    return {"status": "failed", "error": str(e)}
                await asyncio.sleep(2) # Wait before retrying
        return {"status": "failed", "error": "Should not reach here"}

    def check_for_circular_dependencies(self, tasks: List[Dict[str, Any]], task_dependencies: Dict[str, List[str]]):
        path: Set[str] = set()
        visited: Set[str] = set()

        def visit(task_name: str):
            path.add(task_name)
            if task_name in task_dependencies:
                for dep in task_dependencies[task_name]:
                    if dep in path:
                        raise Exception(f"Circular dependency detected: {path}")
                    if dep not in visited:
                        visit(dep)
            path.remove(task_name)
            visited.add(task_name)

        for task in tasks:
            if task["name"] not in visited:
                visit(task["name"])

    async def execute_dag(self, project_manifest: Dict[str, Any]):
        tasks = project_manifest["tasks"]
        task_dependencies = {task["name"]: task.get("dependencies", []) for task in tasks}
        
        try:
            self.check_for_circular_dependencies(tasks, task_dependencies)
        except Exception as e:
            self.logger.error("Failed to execute DAG", error=str(e))
            return

        task_status = {}
        
        if self.repo_manager:
            self.repo_manager.init_repo()

        while len(task_status) < len(tasks):
            runnable_tasks = []
            for task in tasks:
                if task["name"] not in task_status:
                    deps = task_dependencies[task["name"]]
                    if all(dep in task_status and task_status[dep]["status"] == "completed" for dep in deps):
                        runnable_tasks.append(task)

            if not runnable_tasks:
                all_task_names = {t["name"] for t in tasks}
                completed_task_names = {name for name, s in task_status.items() if s["status"] == "completed"}
                if not all_task_names.issubset(completed_task_names):
                    self.logger.error("Could not run all tasks, check for failed tasks or circular dependencies", task_status=task_status)
                break

            results = await asyncio.gather(*[self.execute_task(task) for task in runnable_tasks])
            
            for task, result in zip(runnable_tasks, results):
                task_status[task["name"]] = result
                if task["agent"] == "SecurityAgent" and result.get("high_severity_issues"):
                    self.logger.error("High severity security issues found. Halting execution for human review.", issues=result["high_severity_issues"])
                    review_id = add_review(project_manifest["name"], result["high_severity_issues"])
                    
                    while True:
                        await asyncio.sleep(10)
                        status = get_review_status(review_id)
                        self.logger.info("Polling for review status", review_id=review_id, status=status)
                        if status == "approved":
                            self.logger.info("Review approved. Continuing execution.")
                            break
                        elif status == "rejected":
                            self.logger.info("Review rejected. Calling FixerAgent.")
                            fixer_task = {"name": "fix_security_issues", "agent": "FixerAgent", "description": "Fix high severity security issues."}
                            await self.execute_task(fixer_task)
                            # After fixing, we should probably re-run the security scan.
                            # For simplicity, we will just continue here.
                            break
